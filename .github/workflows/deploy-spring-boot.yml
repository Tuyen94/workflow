name: Reusable Spring Boot Deploy Workflow

on:
  workflow_call:
    inputs:
      java_version:
        description: 'Java version to use'
        required: false
        type: string
        default: '21'
      spring_profile:
        description: 'Spring profile to activate'
        required: false
        type: string
        default: 'prod'
      app_port:
        description: 'Application port'
        required: false
        type: string
        default: '9794'
      additional_volumes:
        description: 'Additional volume mounts (space-separated, e.g., "-v /host/path1:/container/path1 -v /host/path2:/container/path2")'
        required: false
        type: string
        default: ''
      docker_network:
        description: 'Docker network name'
        required: false
        type: string
        default: ''
      base_path:
        description: 'Base path for actuator endpoints (optional, defaults to service name)'
        required: false
        type: string
        default: ''
    secrets:
      SERVER_USER:
        description: 'SSH username'
        required: true
      SERVER_IP:
        description: 'Server IP address'
        required: true
      SERVER_SSH_PASSWORD:
        description: 'SSH password'
        required: true

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      SERVICE_NAME: ${{ github.event.repository.name }}
      APP_PORT: ${{ inputs.app_port }}
      SPRING_PROFILE: ${{ inputs.spring_profile }}
      ADDITIONAL_VOLUMES: ${{ inputs.additional_volumes }}
      DOCKER_NETWORK: ${{ inputs.docker_network }}
      BASE_PATH: ${{ inputs.base_path }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      SERVER_USER: ${{ secrets.SERVER_USER }}
      SERVER_IP: ${{ secrets.SERVER_IP }}
      SERVER_SSH_PASSWORD: ${{ secrets.SERVER_SSH_PASSWORD }}

    steps:
      - name: Set short SHA and downcase REPO
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-8)
          REPO_LOWER=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')
          echo "SHORT_SHA=${SHORT_SHA}" >> ${GITHUB_ENV}
          echo "DOCKER_IMAGE=ghcr.io/${REPO_LOWER}:${SHORT_SHA}" >> ${GITHUB_ENV}

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK ${{ inputs.java_version }}
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ inputs.java_version }}
      - name: Cache Maven repository
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Configure Maven settings.xml for GitHub Packages
        run: |
          mkdir -p ~/.m2
          cat <<EOF > ~/.m2/settings.xml
          <settings xmlns="http://maven.apache.org/SETTINGS/1.0.0">
            <servers>
              <server>
                <id>github</id>
                <username>${{ github.actor }}</username>
                <password>${{ secrets.GITHUB_TOKEN }}</password>
              </server>
            </servers>
          </settings>
          EOF

      - name: Verify Maven installation
        run: mvn --version

      - name: Build and run unit tests with Maven
        run: mvn package -U -B --settings ~/.m2/settings.xml

      - name: Build Docker image
        run: |
          docker build -t ${{ env.DOCKER_IMAGE }} .

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ env.GITHUB_TOKEN }}

      - name: Push Docker image to GHCR
        run: |
          docker push ${{ env.DOCKER_IMAGE }}

      - name: Deploy to Server
        run: |
          # Cài đặt sshpass để sử dụng mật khẩu SSH
          sudo apt-get install -y sshpass
          
          # Tạo file SSH known_hosts để không bị hỏi xác nhận host
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ env.SERVER_IP }} >> ~/.ssh/known_hosts
          
          # SSH vào server, pull Docker image từ GHCR và chạy container
          sshpass -p ${{ env.SERVER_SSH_PASSWORD }} ssh ${{ env.SERVER_USER }}@${{ env.SERVER_IP }} << 'EOF'
            # Login to GHCR
            echo ${{ env.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Create network if not exists (only if network name is provided)
            if [ -n "${{ env.DOCKER_NETWORK }}" ]; then
              docker network create --driver bridge ${{ env.DOCKER_NETWORK }} || true
            fi

            # Pull latest image
            docker pull ${{ env.DOCKER_IMAGE }}

            # Stop and remove existing container
            docker stop ${{ env.SERVICE_NAME }} || true
            docker rm ${{ env.SERVICE_NAME }} || true

            # Run new container with health check
            NETWORK_PARAM=""
            if [ -n "${{ env.DOCKER_NETWORK }}" ]; then
              NETWORK_PARAM="--network ${{ env.DOCKER_NETWORK }}"
            fi

            docker run --restart always -d --name ${{ env.SERVICE_NAME }} \
              --add-host=host.docker.internal:host-gateway \
              -v /var/log:/var/log \
              ${{ env.ADDITIONAL_VOLUMES }} \
              ${NETWORK_PARAM} \
              -p ${{ env.APP_PORT }}:${{ env.APP_PORT }} \
              -e SPRING_PROFILES_ACTIVE=${{ env.SPRING_PROFILE }} \
              ${{ env.DOCKER_IMAGE }}

          EOF

      - name: Wait and Verify Container Health
        run: |
          sshpass -p "${{ env.SERVER_SSH_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.SERVER_USER }}@${{ env.SERVER_IP }} << 'EOF'
            echo "Checking if container exists..."
            docker ps -a --filter "name=${{ env.SERVICE_NAME }}" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

            # Build health check URL
            BASE_PATH_CLEAN="${{ env.BASE_PATH }}"
            if [[ "$BASE_PATH_CLEAN" == /* ]]; then
              BASE_PATH_CLEAN="${BASE_PATH_CLEAN#/}"
            fi

            if [ -n "$BASE_PATH_CLEAN" ]; then
              HEALTH_URL="http://localhost:${{ env.APP_PORT }}/${BASE_PATH_CLEAN}/actuator/health/liveness"
            else
              HEALTH_URL="http://localhost:${{ env.APP_PORT }}/actuator/health/liveness"
            fi

            echo "Waiting for application to be ready..."
            echo "Health check URL: ${HEALTH_URL}"

            RETRY_COUNT=0
            MAX_RETRIES=48
            until curl -f -s "${HEALTH_URL}" > /dev/null 2>&1; do
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -ge $MAX_RETRIES ]; then
                echo "❌ Application failed to become healthy after $((MAX_RETRIES * 5)) seconds"
                echo "Container logs:"
                docker logs --tail 50 ${{ env.SERVICE_NAME }}
                exit 1
              fi
              echo "Waiting for application to start... (attempt $RETRY_COUNT/$MAX_RETRIES)"
              sleep 5
            done

            echo "✅ Application is healthy"
            curl -s "${HEALTH_URL}" | head -n 5
          EOF
