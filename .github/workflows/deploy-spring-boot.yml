name: Reusable Spring Boot Deploy Workflow

on:
  workflow_call:
    inputs:
      java_version:
        description: 'Java version to use'
        required: false
        type: string
        default: '21'
      spring_profile:
        description: 'Spring profile to activate'
        required: false
        type: string
        default: 'prod'
      app_port:
        description: 'Application port'
        required: false
        type: string
        default: '9794'
      additional_volumes:
        description: 'Additional volume mounts (space-separated, e.g., "-v /host/path1:/container/path1 -v /host/path2:/container/path2")'
        required: false
        type: string
        default: ''
      docker_network:
        description: 'Docker network name'
        required: false
        type: string
        default: ''
      base_path:
        description: 'Base path for actuator endpoints (optional, defaults to service name)'
        required: false
        type: string
        default: ''
    secrets:
      SERVER_USER:
        description: 'SSH username'
        required: true
      SERVER_IP:
        description: 'Server IP address'
        required: true
      SERVER_SSH_PASSWORD:
        description: 'SSH password'
        required: true

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      SERVICE_NAME: ${{ github.event.repository.name }}
      APP_PORT: ${{ inputs.app_port }}
      SPRING_PROFILE: ${{ inputs.spring_profile }}
      ADDITIONAL_VOLUMES: ${{ inputs.additional_volumes }}
      DOCKER_NETWORK: ${{ inputs.docker_network }}
      BASE_PATH: ${{ inputs.base_path }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      SERVER_USER: ${{ secrets.SERVER_USER }}
      SERVER_IP: ${{ secrets.SERVER_IP }}
      SERVER_SSH_PASSWORD: ${{ secrets.SERVER_SSH_PASSWORD }}

    steps:
      - name: Set short SHA and downcase REPO
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-8)
          REPO_LOWER=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')
          echo "SHORT_SHA=${SHORT_SHA}" >> ${GITHUB_ENV}
          echo "DOCKER_IMAGE=ghcr.io/${REPO_LOWER}:${SHORT_SHA}" >> ${GITHUB_ENV}

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK ${{ inputs.java_version }}
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ inputs.java_version }}
      - name: Cache Maven repository
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Configure Maven settings.xml for GitHub Packages
        run: |
          mkdir -p ~/.m2
          cat <<EOF > ~/.m2/settings.xml
          <settings xmlns="http://maven.apache.org/SETTINGS/1.0.0">
            <servers>
              <server>
                <id>github</id>
                <username>${{ github.actor }}</username>
                <password>${{ secrets.GITHUB_TOKEN }}</password>
              </server>
            </servers>
          </settings>
          EOF

      - name: Verify Maven installation
        run: mvn --version

      - name: Build and run unit tests with Maven
        run: mvn package -U -B --settings ~/.m2/settings.xml

      - name: Build Docker image
        run: |
          docker build -t ${{ env.DOCKER_IMAGE }} .

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ env.GITHUB_TOKEN }}

      - name: Push Docker image to GHCR
        run: |
          docker push ${{ env.DOCKER_IMAGE }}

      - name: Deploy to Server
        run: |
          # Cài đặt sshpass để sử dụng mật khẩu SSH
          sudo apt-get install -y sshpass
          
          # Tạo file SSH known_hosts để không bị hỏi xác nhận host
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ env.SERVER_IP }} >> ~/.ssh/known_hosts
          
          # SSH vào server, pull Docker image từ GHCR và chạy container
          sshpass -p ${{ env.SERVER_SSH_PASSWORD }} ssh ${{ env.SERVER_USER }}@${{ env.SERVER_IP }} << 'EOF'
            # Login to GHCR
            echo ${{ env.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Create network if not exists (only if network name is provided)
            if [ -n "${{ env.DOCKER_NETWORK }}" ]; then
              docker network create --driver bridge ${{ env.DOCKER_NETWORK }} || true
            fi

            # Pull latest image
            docker pull ${{ env.DOCKER_IMAGE }}

            # Stop and remove existing container
            docker stop ${{ env.SERVICE_NAME }} || true
            docker rm ${{ env.SERVICE_NAME }} || true

            # Run new container with health check
            NETWORK_PARAM=""
            if [ -n "${{ env.DOCKER_NETWORK }}" ]; then
              NETWORK_PARAM="--network ${{ env.DOCKER_NETWORK }}"
            fi

            # Build health check URL based on BASE_PATH
            HEALTH_CHECK_URL="http://localhost:${{ env.APP_PORT }}"
            if [ -n "${{ env.BASE_PATH }}" ]; then
              # Handle BASE_PATH with or without leading slash
              BASE_PATH_CLEAN="${{ env.BASE_PATH }}"
              if [[ "$BASE_PATH_CLEAN" == /* ]]; then
                # BASE_PATH already starts with /, remove the leading slash for URL construction
                BASE_PATH_CLEAN="${BASE_PATH_CLEAN#/}"
              fi
              HEALTH_CHECK_URL="${HEALTH_CHECK_URL}/${BASE_PATH_CLEAN}"
            fi
            HEALTH_CHECK_URL="${HEALTH_CHECK_URL}/actuator/health/liveness"

            docker run --restart always -d --name ${{ env.SERVICE_NAME }} \
              --add-host=host.docker.internal:host-gateway \
              -v /var/log:/var/log \
              ${{ env.ADDITIONAL_VOLUMES }} \
              ${NETWORK_PARAM} \
              -p ${{ env.APP_PORT }}:${{ env.APP_PORT }} \
              -e SPRING_PROFILES_ACTIVE=${{ env.SPRING_PROFILE }} \
              --health-cmd="wget --no-verbose --tries=1 --spider ${HEALTH_CHECK_URL} || exit 1" \
              --health-interval=5s \
              --health-timeout=10s \
              --health-retries=8 \
              ${{ env.DOCKER_IMAGE }}

          EOF

      - name: Wait and Verify Container Health
        run: |
          sshpass -p "${{ env.SERVER_SSH_PASSWORD }}" ssh -o StrictHostKeyChecking=no ${{ env.SERVER_USER }}@${{ env.SERVER_IP }} << 'EOF'
            echo "Checking if container exists..."
            docker ps -a --filter "name=${{ env.SERVICE_NAME }}" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

            echo "Waiting for container to be healthy..."
            timeout 240 sh -c 'until docker inspect --format="{{.State.Health.Status}}" ${{ env.SERVICE_NAME }} 2>/dev/null | grep -q "healthy"; do sleep 10; done'

            # Check if container is healthy
            HEALTH_STATUS=$(docker inspect --format="{{.State.Health.Status}}" ${{ env.SERVICE_NAME }})
            if [ "$HEALTH_STATUS" = "healthy" ]; then
              echo "✅ Container is healthy"
            else
              echo "❌ Container is not healthy"
              exit 1
            fi
          EOF
